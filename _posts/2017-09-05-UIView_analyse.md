# UIView

사각형의 영역을 지정하고 그 영역안에서 표시할 내용을 관리할 수 있는 인터페이스를 정의합니다.



## 개요

기본적으로 UIView 클래스는 배경색으로 사각형의 영역을 칠합니다. 좀 더 복잡한 작업은 UIView클래스를 상속하여 만들 수 있고, UIKit framework에서도 표준 서브 클래스를 제공합니다. UIImageView같은 경우는 UIImage를 그리고 UILabel의 경우는 문자열을 그립니다.



다음으로 뷰의 주요한 역할을 보겠습니다.

- 그리기와 애니메이션
  - 뷰는 UIKit, Core Graphics, 그리고 OpenGL ES와 같은 기술을 이용해 자신의 영역안에 내용을 그립니다.
    - (사실은 영역을 벗어나게 그릴 수도 있습니다.)
  - 뷰에 정의된 몇가지 속성을 통해 애니메이션을 실행할 수 있습니다.
- 레이아웃과 하위 뷰 관리
  - 뷰는 하위 뷰를 가질 수도 있고, 각 하위 뷰는 자신만의 크기조정에 관한 동작을 정의할 수 있으며, 상위 뷰도 하위 뷰의 크기와 위치를 정의할  수 있습니다.
  - 각 뷰는 상위 뷰와 관계하며 자신만의 기본적인 크기 조정 동작을 정의합니다.
  - 뷰는 필요한 경우 하위 뷰의 크기와 위치를 정의 할 수 있습니다.
- 이벤트 다루기
  - UIView는 UIResponder를 상속하고 있고, 덕분에 터치 이벤트와 몇가지 다른 이벤트를 다룰 수 있습니다.
  - addGestureRecognizer(_: ) 메소드를 통해 여러가지 제스쳐를 등록 할 수 있습니다.



뷰는 다른 뷰를 포함하며 복잡한 시각적 계층을 만듭니다. subview와 superview구성된 상위-하위관계를 만들게 됩니다. 보통 하위뷰의 영역은 상위 뷰의 영역에 제한 받지 않지만, clipsToBounds property값을 변경해서 제한하도록 설정할 수 있습니다. 상위 뷰는 여러개의 하위 뷰를 가질 수 있지만, 하위 뷰는 단 한개의 상위 뷰를 가집니다.

뷰의 기하학적 배치는 frame, bounds, center 속성을 통해 정의됩니다. frame은 상위 뷰의 좌퓨계에서 위치와 크기를 정의합니다. center는 뷰의 크기를 변경하지 않은 채로 뷰의 중심좌표만을 변경합니다. bounds는 특별히 값을 이용하지 않은 한은 뷰의 크기에만 관여합니다. frame과 bounds 어느 한 쪽의 크기 변경은 다른 쪽의 크기도 변경하게 됩니다.

> **Note**
>
> iOS 2.x에서는 UIView의 최고 크기가 1024 x 1024 point로 제한되었습니다. iOS 3.0부터는 더 이상 제한 없지만, 여전히 메모리 크기에 제한을 받습니다.



### 뷰 생성

프로그래밍적으로 뷰를 생성하기 위해서는 다음과 같은 코드를 사용할 수 있습니다:

```swift
let viewRect = CGRect(x: 10, y: 10, width: 100, height: 100)
let myView = UIView(frame: viewRect)
```

위의 코드는 상위 뷰의 좌표계에서 10, 10의 위치에 100의 너비와 100의 높이를가진 뷰를 생성합니다. 뷰를 다른 뷰의 하위 뷰로 만들려면 **addSubview(_: )** 메소드를 사용합니다. 이웃하는 하위 뷰들은 별 문제 없이 겹쳐질 수 있습니다. 뷰는 **addSubvie(_: )** 를 통해 더해진 순으로 다른 이웃뷰들의 위에 위치하게 됩니다. **insertSubview(: aboveSubview:)** 나 **insertSubview(:belowSubview:)** 메소드를 통해서 하위 뷰를 더할 때 z축의 순서를 특정할 수도 있습니다. **exchangeSubview(at:withSubviewAt:)**을 통하면 하위 뷰들의 순서를 서로 바꿀 수도 있습니다.



### 뷰 그리기 과정

- 뷰 생성, 혹은 레이아웃 변경시 시스템이 뷰에 내용을 그리도록 요청
- 뷰가 UIKit이나 Core Graphics를 사용하는 내용을 포함하는 경우 시스템은 뷰의 **draw(_:)** 메소드를 호출
- 직접 이 메소드를 구현하는 경우 현재의 graphics context를 이용하여 뷰의 내용을 그림

뷰의 내용을 변경할 경우 당신은 뷰의 내용이 변경되었음을 시스템에 알려야 합니다. **setNeedsDisplay()** 나 **setNeedsDisplay(_:)** 메소드를 통해 알릴 수 있습니다. 이 메소드를 통해 시스템은 다음 그리기 과정에서 뷰를 갱실할 필요가 있음을 알게 됩니다.



### 애니메이션

- 애니메이션의 실행
  - iOS 4 이후부터 block 함수 기반의 메소드가 추가 되었습니다. 추천
    - animate(withDuration:animations:)
  - begin/commit 애니메이션 메소드
    - beginAnimations(_:context:)을 호출
    - 애니메이션 속성을 설정
    - commitAnimations()로 애니메이션을 실행
- 애니메이션 가능한 속성
  - frame
  - bounds
  - center
  - transform
  - alpha
  - backgroundColor



### 스레드에 대해 고려할 점

뷰의 생성은 어느 스레드에서도 가능하지만, 그 밖의 뷰와 관련한 작업은 메인 스레드를 통해서 실행해야 합니다.



### 뷰의 상속

뷰를 상속하여 사용할 좋은 이유가 많긴 하지만, 되도록이면 UIView혹은 UIKit에서 제공하는 뷰가 원하는 기능을 제공하지 못할 경우에만 사용하시는 것이 좋습니다. 뷰의 상속은 많은 작업을 필요로 하고 퍼포먼스에 대한 조정이 필요합니다.

#### 오버라이드 할 메소드

- 초기화
  - **init(frame:)** - 추천하는 메소드입니다. 물론 이 메소드 대신 다른 초기화 메소드를 만들 수도 있습니다.
  - **init(coder:)** - 당신이 만든 뷰가 인터페이스 빌더를 통해 생성되며, 사용자화된 초기화가 필요할 경우 구현하세요.
  - **layerClass** - 특별한 목적의 Core Animation layer를 사용할 경우에만 이 속성을 구현하세요.
- 그리기, 프린트하기
  - ​